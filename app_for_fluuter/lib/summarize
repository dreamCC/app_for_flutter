2019.8.6
1、手势。GestureDecorator、Inkwell、Listener几个监听手势。可以配合Transform使用。
2、Transform的使用。一般不直接使用，因为内部嵌套的Matrix4使用比较麻烦。
    配合暴露的方法。Transform.rotation、Transfor.scale、Transform.translate使用起来会方便很多。
3、动画。牵扯到几个关键类。AnimatedController、Animatable（通过插值类Tween及其衍生类获取的）、Animation（通过Animatable获取）。
    真正进行动画的可以有几种方式。Animation.addListen(){ setState() }、使用xxxTransition、使用Animatedxxxx(如AnimatedContainer等，这种实现方式需要利用其value值)。
4、线程问题。Future类。Dart中，事件循环的两个主要事件类，MicroTask和EventTask，我们需要知道其工作方式。
    Future()、Future.microTask() 创建异步线程。这里需要注意的是：创建的异步线程都是串行队列。
    dart/ioslate 可以创建并发队列。但是不同线程间的传递有点麻烦。
    sleep() 函数，存放在dart/io里面。
5、IO操作。File类操作文件、Director类操作文件夹。
    Director操作文件夹其实很简单。
    File类，操作文件。牵扯到两种情况，其实和其它语言一样。字符流操作、字节流操作。
    字符流：直接调用其方法。字符流，只能用于操作文本文件，因为其内部原理，相当于将字节转为字符，然后在将字符转字节，所以如果有比如音频文件，
        那么转字符的时候会出现乱码。导致文件孙华。
    字节流：牵扯到读流Stream、写流IOSink。
6、Regex。正则表达式。


2019.8.7
1、Overlay和OverlayEntry的搭配使用。Overlay的本质就是MeteralApp会创建一个Stack组件，内部包含了OverLay。
2、Materail控件的使用。
3、ReorderListView。用于cell间的位置交换。需要注意onReorder方法的实现。
4、Dismissable的使用。注意是滑动删除。
5、DataTable的使用。用于数据的展示。但是其样式比较固定。可能不会直接使用，或者使用需要进行改动。


2019.8.8
1、Form搭配FormTextField使用。其作用是，可以用来进行字段校验validation。
2、extents、with、implement三个关键字的区别。
    extents继承，当父类方法没有实现，那么就必须重写。
    implement不管父类有没有实现，其子类都需要实现。
    wit比较特殊，当我们像要实现多继承的时候，需要用到with关键字。而且with后面的，如果是class，那么就必须要继承Object类。如果继承的不是Object类，
        需要用到关键字mixin和on来实现。
3、字符串String = r"xxxxx \n xxxxx"; 创建的raw字符。里面的所以字符都是字符比如\n就是字符，而不是换行。正则表达式可以使用。其实类似\n前面加\。
    即\\n。
4、const修饰List数组，那么就不能向里面添加内容。const 修饰construction函数。那么其属性都必须是final类型的。
    const相对于final，其不可变是会传递的。比如，用final修饰 数组，数组还是可以变的。但是const修饰那么数组是不会变的。
    总的来说，const限制条件更加苛刻。
5、函数中的参数，有可选命名参数和可选位置参数。主要是参数名字是否写上的问题。可选位置参数是不需要写的，可选命名参数需要写。
6、factory工厂构造方法。 和其它的构造方法的区别就是。factory构造方法需要手动return 对象。
7、ListView可以通过。buildChildLayout来将其转换为，SliderListView。
8、Opacity控件。SingleChildRenderObjectWidget。
9、继承自Widget的有，StatelessWidget、StatefullWidget、RenderObjectWidget。其中：
    RenderObjectWidget有三个子类，SingleChildRenderObjectWidget、LeafRenderObjectWidget、MulitChirldRenderObjectWidget。
    我们使用的所有Widget的本质，其实就是上面三种。但是我们接触的一些Widget会发现经常继承StateLessWidget、StateFullWidget，这些widget会调用
        build方法，而系统的一些Widget的build的实现还是RenderObjectWidget。比如Text是StatelessWidget，但在build方法中，会创建RichText，
        而RichText是SingleChirldRenderObjectWidget。
    所以说，真正搬砖的是我们这些程序员。
10、Widget、Element、RenderObject关系。Widget配置信息，Element显示的控件，而使其显示的绘画过程右RenderObject来完成。
    其实是Element将RenderObject挂载到RenderTree上面。

2019.8.9
1、MethodChannel实现native和flutter进行交互。
2、PreferrSize对Appbar进行包裹，可以设置appbar的高度。PreferSize单独使用并不会限制子控件的尺寸，只是表明了想要子控件呈现的高度。
3、PreferSizeWidget，抽象类。其实现该类的有，AppBar、ToolBar、PreferSize。
4、WidgetsBindingObserver用来监听app的状态。其中有几个方法需要知道其作用：
    didChangeMetrics() 尺寸改变。横竖屏、键盘弹出。
    didChangeAppLifecycleState() app状态改变。前后台方面。
5、State的deactivate()方法，是在widget从widgteTree中移除的时候调用。会在dispose()方法调用前调用。
6、Context.size 获取widget的尺寸，前提是build（）结束。
7、context.findRenderObject()  获取widget相应的RenderObject。
8、window和MeidaQueyaData都能获取设备的一些信息。

2019.8.12
1、widget中key的作用。主要是确定widget相对应的ElementTree中的Element是通过什么方式来进行更新的。如果Widget的runtimeType和key都相等，
    那么Widget的canUpdate方法返回true。相应的Element会通过update方法来进行更新。如果不同，那么会通过Element的remove、add的方式更新。
2、Element的生命周期。
    a、框架通过widget的creatElement创建element。
    b、然后框架调用mount方法，将element添加到element tree中。并且会根据需要，调用attachRenderObject方法，将相对应的renderObject添加到
        Render tree中。此时，element变为 active状态。
    c、如果widget进行了rebuild，那么会通过widget的runtimeType和key来判断element是进行udpate还是进行remove操作。如果remove那么element
        变成无效状态。并且会将其从element tree中进行卸载。
3、RenderObject类是负责渲染的（主要包括布局和绘制）。因为其没有坐标系，所以我们一般使用其子类RenderBox（内置一个笛卡尔坐标系和原生ios、android坐标系一样）。
    一般情况，自定义UI。我们通过自定义Widget和CustomPaint就能够实现。但是，如果需要特殊情况，我们可以通过继承RenderBox来实现。
4、时间DateTime。通过showDatetimePicker 可以显示日期选择器。 TimeOfDay。通过showTimeOfPicker() 显示时间选择器。
5、Timer定时器。在dart：async库中。方法很简单，创建延迟调用和重复调用的两种情况。
6、Theme。默认MaterialApp有一个默认主题。同时我们可以使用Theme这个Widget进行局部主题设置。
    所以Theme都是由ThemeDate来进行数据管理的。 有几个重要方法，copy、of(context)。
    ThemeData(
          primarySwatch: Colors.purple, //样本颜色。其很多主题受此影响。
          accentColor: Colors.purple, // 文本、按钮。
          accentColorBrightness: Brightness.light, // 亮度。
          primaryColor: Colors.purple, // 主要颜色。Appbar、TabBar。
          textTheme: TextTheme(
            button: TextStyle(fontSize: 20)
          )
        ); // 常用的可能就这么多。内部有很多配置，其实在使用的时候在进行配置就可以。
7、关键字。
    show、hidden一般用于import 'xxxx' show/hidden xx;  表示使用库中的一部分。 比如.dart 文件中有多个类，我们可以通过使用
        show（导入整个库中的 xxxx）、hidden（导入整个库除了xxxx）来进行选择导入指定的类。

    final 会进行类型推导。

    as、is、is！其中is和is！很好理解，就是判断是是否是一个类或其子类。其实就是oc中，isMemberOf和isKindOf两个的结合体。
    as有两个用途。1、类型转换。向下转换。(superClass as subClass).xxxx父类转子类，调用其子类方法。
                2、给指定.dart文件添加前缀。
                    import 'aaa.dart';
                    impoot 'bbb.dart';
                    如果aaa.dart 和bbb.dart中，同时有相同类xxx。那么我们使用xxx去创建的时候就有问题。此时可以通过
                    import 'bbb.dart' as B; 那么使用bbb.dart中的类就需要通过B.xxxx 来进行创建。有点类似swift中的命名空间。

    mixin on / with（混入。如果类没有是实现，那么就必须要实现） implements(和java一样必须要实现) extents（继承）。
    mixin on xxx 指定只有实现了on 后面的xxx才能进行混入，on其实也就是进行了混入限定。 常用于继承state类。
    with后面的类有一个特点：如果with后面是class，那么class必须是继承自Object类。所以，这大概就是引入mixin on的原因吧。

    typedef 和其它语言的typedef的作用没什么区别。但是语法有些不同。比如oc中，我们可以声明任意类型、block： typedef int xxx;
    dart中只能声明函数。typedef XXX = xx Function();

    defferred as 常用语import 'xxxxx.dart' defferred as XXX;表示该库为延时加载库，通常还需要给其重命名。

    covariant 协变。

    operator 操作符。如果我们想要一些操作符比如 + - == 等操作符，需要用该关键字，比如重写==方法。
    @override
      bool operator ==(other) {
        // TODO: implement ==
        return true;
      }

2019.8.13
1、Android Studio调试。 Systerm.out.println("xxxxx"); 比如断点打在这个位置：
    a、step over（使用比较频繁）。表示我们println方法视为一步，越过该函数（该函数执行完毕）执行下一步。
    b、step into。 跟上面的刚好相反，它会进入println方法内部执行。（严格意义上的一步一执行）。
    c、force step into。 感觉和step into效果一样。
    d、step out。一般配合step into使用。表示跳出进入的函数。step into和step out成对使用，其实就是step over的效果。
    e、step to curse。 执行到光标所在位置。这个就很好理解。

    上面是比较基础的调试。像一些高级调试技巧：
    a、Evaluate Expression。就是step to curse右边的小计算器。功能很强大。我们可以通过输入一些调教，来获取相应的输出。
    b、条件断点。我们可以给断点输入条件，来进行筛选。比如for循环中，我们使用条件断点。
    c、异常断点。xcode其实也有这个功能。通过Run->View breakPoints来进行添加。这样就能够更加准确的定位错误信息。


2019.9.9
1、flutter中，set & get。
    默认添加属性（非私有），系统会提供set、get方法。我们通过.语法可以调用set和get。这个和oc的原理很像。和java就很不一样。java中的点语法
    其实是直接访问成员变量，java虚拟机并不会给其添加set、get方法，如果想要添加，我们需要手动添加set、get方法。

    flutter中，点语法的写法。 String get name {}, set name(String xx){} 后面大括号可以使用 => 来代替。
2、 flutter中，资源文件的控制。通过 pubspec.yaml 文件，来指定资源文件路径如下，assets就是我们穿件的文件夹（当然，我们不一定非要使用这个名字）。
      assets:
        - assets/
     我们通过import 'package:flutter/services.dart'; 文件下面，我们可以使用rootAssetBundle 或者 PlateFormAssetBundle来获取pubspec.yaml指定
     的资源路径。
3、 对fullter， StreamController的理解。 StreamController相当于一机器，该机器有入口sink（StreamSink）， 出口stream（Stream），
    通过sink.add 添加数据， stream.listen（StreamSubscribe） 来监听数据。
    StreamController两种初始化方法，StreamController()单订阅，即只能调用一次listent，取消后不能再次监听 和 StreamController.broadcast()广播，即可以多次listent。
    StreamController注意关闭。
4、Theme和ThemeDate的搭配使用可以有效的控制主题。

2019.9.10
1、widget树间的传值。
    自上向下——继承自InheritedWidget实现。 我们常用的MediaQurey其实就是继承自InheritedWidget的。
        其实自上向下传值，我们直接借助参数传值也是可以实现的。
    自下向上——继承自Notifycation配合，NotifycationLisent实现。
2、通过WidgetBindingObserver需要配合WidgetBing.instance.addOberser(this)；来实现一些监听。当然，我们也可以直接使用，
    WidgetBinding.instance.addxxxxxxxxx来进行一些监听。
3、dart:math 库中，Random()生产随机数类、pi、常用函数。
4、Transfom.translate( chirld: GestureDecrator() )。 Transform.translate搭配GestureDecorater使用，可以进行拖动动画等。
5、AnmatedList可删除、增加的Widget的使用。主要是globleKey、数据、动画的搭配使用。
    关于动画，Animation本身是一个抽象类。我们一般使用Tween插值(Animationable)动画来获取Animation。有一个drive方法。

2019.9.11
1、Material控件的使用。
2、Image和ImageProvider的区别。Image通过Image.asset等方法获取，ImageProvider通过AssetImage等获取。FadeInImage可以添加占位图。
3、自定义路由。PageRouteBuilder的使用，注意蒙版的使用。
4、圆形/圆角。圆形：ClipOvral、CircleAdapte。 圆角：ClipRRect。
5、ShaderMask添加蒙版。 注意Shade着色，可以通过Griender.createShader来进行获取。
6、直接使用 .0表示一个浮点型数据。

2019.9.12
1、源于Picker的使用，flutter自带，MonthPicker、DayPicker、TimePicker等，一般不会直接使用，通过show来实现。
2、CupertenoPicker一般不会直接使用，需要通过showCupertenoModalPopup()来实现。
3、Scaffold脚手架有几个重要方法，Scaffold.of(Context).showSnakeBar/showBottomSheetxxxxx/showBodyScrim(显示一个蒙版)，主要可以成功是因为，Scaffold在源码里面，
    有添加相应的控件，便于我们使用。
    1、我们可以从其中学习到其中的设计思路。 当调用show的时候，会调用其setState，而setState里面会添加相应的标识，在build的时候，通过相应的
    标识，来确定界面显示方式。

2019.9.16
1、Flutter中，提供的show方法的使用。
    showGeneralDiaolog，这个是最原始的方法。其中，showDiaolog、ShowCupetenoDialog、showDatePicker等都是直接或间接使用该方法显示的。
    showBottomsheet和showModalBottomSheet的区别。
        showBottomSheet是通过Scafold.of(context).showxxx来实现。
        showModalBottomSheet是通过自定义转场来是吸纳。
    showCupertinaoModalpopup 也是通过自定义转场来实现。 其实效果都是一样的，从下往上。
2、SafeArea的使用。
3、MediaQuery.removePadding这个其实也是移除安全距离的，和SafeArea类似，如果我们看源码就会发现，其实SafeArea的源码就是，通过removepadding来实心的。

2019.9.18
1、关于Appbar。evalution阴影高度、centerTitle=true
2、TabBar和TabBarView的搭配使用，牵扯到TabController。 AppBar和TabBar都是可以通过PreferSize来进行高度设定。
    TabBar是可以单独使用的。
3、Flutter创建app的层次结构。其实和ios（window->rootViewController->TabBarController->chirldControllers->NavigationController）一样。
    Flutter相当于，MateralApp(bottomNavigationBar、body)，其中body就是每个页面，而Scaffold直接可以设置body的naviagtionBar。
    其实每个页面都可以有，bottomNavigationBar，上面只是我们正常app的一般层次结构，根据实际开发，可以调整。
    所以Flutter更像是搭积木的形式，每个部位的widget都是随意搭配。
4、BottomNavigationBar重要属性，onTap和currentIndex来控制index显示。
    注意，因为Scaffold中，bottomNavigationBar是widget类型，所以我们可以使用自定义的，比如Container和BottomAppBar搭配使用。
5、BottomAppBar的特点是，有一个evalution，而且样式已经有默认的。
6、Flex、Row、Column其实功能一样。类似Android的线性布局。其中Row、Column是继承自Flex。所以，如果能使用Row、Column那么就一定能使用Flex。
    Flex、Row、Column内部配合Expanded使用。
    Expanded的特点，就是会占用剩余空间，所以Row里面有多个widget和多个Expanded时候的样式，我们需要知道其规律。
    Flexible也是配合Flex、Row、Column使用。但是他不会强制使子widget铺满空间。感觉使用场景不多。
    Space(),默认提供一个flex = 1的间距。用来控制间距使用。
    对于mainAligment，crosAligment（其中strtch表示交叉轴上面铺满）、texDirection（水平方向）、verifyDirection的理解。
7、Color的使用，直接初始化，传16进制数。0xAARRGGBB 是上诉格式，其中aa可以是00透明或者ff不透明。

2019.9.19
1、json相关知识。json属于convert包。
    所以与json相关的知识，有一个总的封装类JsonCodec，可以处理json->modal、modal->json。
    JsonCodec，有两个get方法分别获取，JsonDecoder和JsonEncoder来分别处理，当然也暴露两个方法encode()、decode()两个方法。
    所以json中，转换的本质是通过JsonEncode().convert()、JsonDecoder().convert()进行的。
    实际上我们可以直接使用，jsonEncode()、jsonDecode()来进行转换，这是flutter封装好的方法。
2、关于dio知识点。
    Dio dio =Dio([BaseOptions options])；进行初始化时候，可以设置baseoptions。
    dio.request(); 进行网络请求。 其中我们可以设置options，（RequestOptions、Options）进行请求方法等设置。
        当然，我们可以直接使用post、get、put等封装后的方法进行请求。
    因为该方法是Future类，我们可以通过.catchError或者是try{ } on DioError catch(error) { }来进行错误捕捉。
3、Flutter中app运行机制，就是有两个队列，microTasks、EventTasks。而Flutter中，所以任务都是存放在任务队列eventTasks中，而且是串行执行。
    和oc、java不同的是，oc、java不管是什么线程如果异常没有处理就会直接崩溃。但是flutter不会，flutter中，如果异常那么知识该队列不会执行，
    并不会程序退出。而会继续执行队列中的其他任务。
    Flutter中，通过Future() 来创建一个异步操作，如果有返回值，那么必须是Future类型。async、await其实是dart对异步操作的一个语法糖。
    这个其实和ios中的dispatch差不多。
4、Flutter中的异常捕获，
    如果是正常方法中throw 的异常，通过try-catch进行捕获。
    future中throw的异常，通过 future.catchError捕获、或者是通过try{ await futurnFunc()  }catch { }捕获。
5、async标识一个方法具有异步能力。如果如果内部调用Future创建对象，那么才会是异步方法。
    async、Future、await的关系。
    注意async关键字的使用场景，并不是有Future的函数一定要使用async进行标记。
    一般async和await是成对出现的（没有使用await，函数标记为async也没什么意义。 使用await就必须要使用async来进行函数标记。）
    async/await只是相对于标记的函数的。
    Future才是实现异步的核心代码。Future包裹的代码块里面才是执行异步的操作。如果出现Future，那么里面的耗时操作就是开启子线程执行，Future
    类似ios中的Dispath。
    而async/await只是相对于标记函数是否等Future内部代码执行完在执行。

  Future<T>的返回写法。 注意下面返回值是11。而且需要注意的是then返回的也是Future类型。在实际开发中，一般不用这样写，直接返回Future就ok了。
  then只是表示，Future代码块执行完后，执行该操作。
  Future<int> futureMehod() {
    print("开始");
    return Future((){
      sleep(Duration(seconds: 2));
      print("future 执行");

      return 12;

    }).then((value){
      print("future then");

      return 11;
    });
  }

2019.9.20
1、对于Card组件的使用，由于Card组件的特性，我们可以多使用Card组件来代替Container组件。
    其实Card的源码可以看出，Card其实就是Container，增加evaluation的结果。
2、Hero组件，配合PageRoute来进行一些特殊效果。PageRoute中，重要属性，pageBuilder、transitionBuilder(常见SliderTransition、FadeTransition)等。
3、Dart是单线程模型语言。 Dart的循环机制。 isloate。

2019.9.23
1、ExpensionTitle二级及多级菜单的展示，其实和ListTitle的基本功能是一样的，其trailing默认是个向下箭头，知识增加了点击，展示chirldren的能力。
    ListView配合ExpensionTitle就可以实现展开效果。
    ExpansionPanelList其实和上面组合实现的效果一样。
2、AspectRadio用于调整控件的宽高比。
3、FittedBox，主要属性fit(BoxFit类型)用于控制子控件显示的方式。这个其实和Image的fit很类似。
4、Stepper的使用，用于一步一步执行的widget。
5、chip小控件的使用。有几个特殊的，ActionChip带点击事件的、FilterChip点击时候左侧有✅的、
    ChoiceChip（和FilterChip不同的是，其左侧没有✅）最常用的。

2019.9.30
1、关于动画。通过源码我们知道，使用XXXTransition和AnimatedXXX都是继承AnimatedWidget。
    AnimatedWidget的特点：通过传入的一个LisenAble（Animation继承Lisenable），会进行动画监听（其实就是调用addLissent方法），
    调用_handleChange() { setState}。
    XXXTransition和AnimatedXXX的不同点就是：
    XXXTransiton在setState的时候会获取lisentable.value的值。
    AnimtedXXX在setState的时候不会去重新获取lisentable.value的值。 所以，一般使用XXXTransition会方便一些。

   我们知道动画AnmationController需要传入sync: Tikerprovider。TikerProvider的作用就是生成Tiker。而Tiker就是
   获取屏幕每一帧的刷新通知（实现动画的核心）。类似ios中，CADisplayLink。所以有动画的地方就需要TikerProvider。

   、、所以动画的原理其实就是，通过TikeProvider获取每一帧的刷新通知，当通知来了获取Tween插值所计算出来的动画值，然后
   调用setState进行刷新。

   需要注意一点就是：动画当页面销毁时候，我们需要手动调用xxxx.dispose()避免浪费资源。其实通过源码发现就是移除了监听。

2、Flutter中所有能够滚动的控件都是直接或者间接使用ScrolleAble组件的。而ScrollerAble能实现滚动的核心是有ViewPort组件。
3、PageView使用了ScrollAble组件，而且还使用了TikerProvider来提供动画。
4、WillPopScop用来监听Navigator.of().pop。


2019.10.12
1、关于extents、with、implement的加深理解。 其实dart中的类也可以理解为接口（没有interface关键字）。
    1、extents继承父类。 如果父类方法没有实现（父类是抽象类）,那么子类必须要实现。如果父类实现了，子类可以不去重写。
    2、implements也是继承父类。和java中的implement含义不一样。dart中implements不管父类有没实现，子类都要实现。
    3、mixin混入。 mixin修饰的也是一个类（最少可以理解为一个类, 但是不能使用关键字extents）。
        使用场景。比如一个 A extents B with C 这个时候C也是一个类，而且C必须要继承Object。 如果C 不是继承Object，
        那么就需要使用mixin C on State{} ，通过mixin/on来修饰C。

2、CircleAdvate的误区。如果使用该控件进行切圆角，我们必须将圆角图片设置为backgroudImage。从这个角度来讲我们使用Container
    也是可以实现的。 它的chirld的属性的理解，相当于在原控件上放一个subView, 从源码可以发现，其实就是一个AnimatedContainer。
    所以实现切圆角，最好使用ClipOvel、ClipRRect。

3、AutomaticKeepAliveClientMixin该混入类。 注意其build方法是@mustcallSuper的。如果我们with AutomaticKeepAliveClientMixin。
    那么build方法，就必须要调用super.build()。 如果不调用我们会发现有一个小警告。
    注意AutomaticKeepAliveClientMixin的源码。

    AutomaticKeepAliveClientMixind常用使用场景是PageView、TabView的子widget使用。但是实际上，使用不局限于此。之所以需要调用
    super.build(context)的原因就是，其内部是通过_ensureKeepAlive()方法确保切面状态保护，之所以能保存状态就是需要我们在state各种
    生命周期方法中调用该方法才行。。 有个场景就是，当我们push到下一页面，然后在pop回来的时候，，调用build方法，如果我们不调用super.build就无法调用到_ensureKeepAlive()
    方法来保存状态。


2019.10.14
1、dart中的mixin其实更像abstract class。 里面可以声明方法，而且声明的方法可以实现或不实现。
2、dart中的set、get方法和swift中set、get方法一样，只能作为计算属性。

2019.10.16
1、Column中的chirld： 会尽可能缩小子控件大小。所以我们才需要配合Expande使用。
2、对于手势GestureDecorator的源码理解。之所以能进行手势识别，其核心是，GestureRecognize（手势识别器。）。
    起源码也是很简单，就是使用RawGestureDecorator。